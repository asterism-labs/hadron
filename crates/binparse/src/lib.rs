//! Safe binary data parsing for `no_std` environments.
//!
//! Provides the [`FromBytes`] trait for types that can be safely read from raw
//! byte buffers, and a [`BinaryReader`] cursor for sequential reads. The unsafe
//! `FromBytes` implementations are generated by the `#[derive(FromBytes)]` macro
//! from `hadron-binparse-macros`, which verifies `#[repr(C)]` layout at compile
//! time.

#![no_std]
#![warn(missing_docs)]

pub use hadron_binparse_macros::FromBytes;

/// Types that can be safely read from a raw byte buffer.
///
/// # Safety
///
/// Implementors must guarantee that:
/// 1. The type has a well-defined memory layout (i.e., `#[repr(C)]` or primitive).
/// 2. Every possible bit pattern of the correct size is a valid value of the type.
/// 3. The type implements `Copy` (no drop glue, no interior pointers).
///
/// Use `#[derive(FromBytes)]` from `hadron-binparse-macros` to generate
/// implementations with compile-time layout verification.
pub unsafe trait FromBytes: Sized + Copy {
    /// Reads a value of type `Self` from the start of `bytes`.
    ///
    /// Returns `None` if `bytes` is shorter than `size_of::<Self>()`.
    fn read_from(bytes: &[u8]) -> Option<Self> {
        if bytes.len() < core::mem::size_of::<Self>() {
            return None;
        }
        // SAFETY: We verified sufficient length. `read_unaligned` handles any
        // alignment. The trait contract guarantees all bit patterns are valid.
        Some(unsafe { core::ptr::read_unaligned(bytes.as_ptr().cast::<Self>()) })
    }

    /// Reads a value of type `Self` at the given byte offset within `bytes`.
    ///
    /// Returns `None` if the offset + size exceeds the buffer length.
    fn read_at(bytes: &[u8], offset: usize) -> Option<Self> {
        bytes.get(offset..).and_then(Self::read_from)
    }
}

// Built-in implementations for primitive integer types.
// SAFETY: All integer types have defined layout, accept all bit patterns, and are Copy.
unsafe impl FromBytes for u8 {}
unsafe impl FromBytes for u16 {}
unsafe impl FromBytes for u32 {}
unsafe impl FromBytes for u64 {}
unsafe impl FromBytes for i8 {}
unsafe impl FromBytes for i16 {}
unsafe impl FromBytes for i32 {}
unsafe impl FromBytes for i64 {}

// SAFETY: Fixed-size byte arrays have defined layout and accept all bit patterns.
unsafe impl<const N: usize> FromBytes for [u8; N] {}

/// A sequential cursor over a byte buffer for reading binary data.
///
/// Tracks a position that advances with each read, providing a convenient way
/// to parse structured binary data without manual offset arithmetic.
pub struct BinaryReader<'a> {
    data: &'a [u8],
    pos: usize,
}

impl<'a> BinaryReader<'a> {
    /// Creates a new reader over the given byte slice, starting at position 0.
    #[must_use]
    pub fn new(data: &'a [u8]) -> Self {
        Self { data, pos: 0 }
    }

    /// Reads a value of type `T` and advances the position.
    ///
    /// Returns `None` if there are not enough bytes remaining.
    pub fn read<T: FromBytes>(&mut self) -> Option<T> {
        let value = T::read_from(self.data.get(self.pos..)?)?;
        self.pos += core::mem::size_of::<T>();
        Some(value)
    }

    /// Skips `n` bytes, advancing the position.
    ///
    /// Returns `false` if there are fewer than `n` bytes remaining.
    pub fn skip(&mut self, n: usize) -> bool {
        if self.pos + n > self.data.len() {
            return false;
        }
        self.pos += n;
        true
    }

    /// Returns the remaining unread bytes.
    #[must_use]
    pub fn remaining(&self) -> &'a [u8] {
        &self.data[self.pos..]
    }

    /// Returns the current byte position.
    #[must_use]
    pub fn position(&self) -> usize {
        self.pos
    }

    /// Returns the total length of the underlying buffer.
    #[must_use]
    pub fn len(&self) -> usize {
        self.data.len()
    }

    /// Returns `true` if the underlying buffer is empty.
    #[must_use]
    pub fn is_empty(&self) -> bool {
        self.data.is_empty()
    }

    /// Returns `true` if there are no remaining bytes to read.
    #[must_use]
    pub fn is_at_end(&self) -> bool {
        self.pos >= self.data.len()
    }

    /// Returns a reference to the full underlying buffer.
    #[must_use]
    pub fn data(&self) -> &'a [u8] {
        self.data
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn read_u32_from_bytes() {
        let bytes = 42u32.to_ne_bytes();
        assert_eq!(u32::read_from(&bytes), Some(42));
    }

    #[test]
    fn read_from_short_buffer() {
        let bytes = [0u8; 2];
        assert_eq!(u32::read_from(&bytes), None);
    }

    #[test]
    fn read_at_offset() {
        let mut buf = [0u8; 8];
        buf[4..8].copy_from_slice(&0xDEAD_BEEFu32.to_ne_bytes());
        assert_eq!(u32::read_at(&buf, 4), Some(0xDEAD_BEEF));
    }

    #[test]
    fn read_at_out_of_bounds() {
        let buf = [0u8; 4];
        assert_eq!(u32::read_at(&buf, 2), None);
    }

    #[test]
    fn binary_reader_sequential() {
        let mut buf = [0u8; 12];
        buf[0..4].copy_from_slice(&1u32.to_ne_bytes());
        buf[4..8].copy_from_slice(&2u32.to_ne_bytes());
        buf[8..12].copy_from_slice(&3u32.to_ne_bytes());

        let mut reader = BinaryReader::new(&buf);
        assert_eq!(reader.read::<u32>(), Some(1));
        assert_eq!(reader.read::<u32>(), Some(2));
        assert_eq!(reader.read::<u32>(), Some(3));
        assert_eq!(reader.read::<u32>(), None);
        assert!(reader.is_at_end());
    }

    #[test]
    fn binary_reader_skip() {
        let buf = [0u8; 16];
        let mut reader = BinaryReader::new(&buf);
        assert!(reader.skip(8));
        assert_eq!(reader.position(), 8);
        assert_eq!(reader.remaining().len(), 8);
        assert!(!reader.skip(20));
    }

    #[test]
    fn read_byte_array() {
        let buf = [1u8, 2, 3, 4];
        let arr: [u8; 4] = <[u8; 4]>::read_from(&buf).unwrap();
        assert_eq!(arr, [1, 2, 3, 4]);
    }
}
